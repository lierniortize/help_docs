<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>REDIS - Dokumentazioa</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "REDIS";
    var mkdocs_page_input_path = "redis.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Dokumentazioa</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">HASIERA</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../links/">LINKS O INFORMACIÓN</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../storage/">STORAGE</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../beam/">APACHE BEAM</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../pandas/">PANDAS</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../airflow/">AIRFLOW</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../django/">DJANGO</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../bigquery/">BIGQUERY</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../prophet/">PROPHET</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">REDIS</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#basic-data-structures">BASIC DATA STRUCTURES</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#keys-and-expiration">Keys and Expiration</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#set">SET</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get">GET</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#keys-and-scan">KEYS and SCAN</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#borrar-llaves">Borrar llaves</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#del">DEL</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exists">EXISTS</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#incr-y-incrby">INCR y INCRBY</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#decr-y-decrby">DECR y DECRBY</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#expire-y-ttl">EXPIRE y TTL</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#listas">LISTAS</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#python">PYTHON</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#connect-to-redis">Connect to redis:</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#redis-clients">Redis Clients</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#como-conectarse-a-redis-utilizando-redis-py">Cómo conectarse a redis utilizando redis-py</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#basic-operations">Basic operations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#daos">DAOs</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#redisearch">REDISEARCH</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#querying">QUERYING</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#finding-exact-string-matches">Finding exact string matches</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#redis-om">REDIS OM</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#creamos-un-redis-model-en-om">Creamos un Redis Model en OM:</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cargar-datos-en-redis">Cargar datos en redis</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#querys">Querys</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#redis_om-y-redisearch">REDIS_OM y REDISEARCH</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#iniciar-redis-en-windows">Iniciar Redis en Windows</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#redisinsight">RedisInsight</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creamos-un-redis-model-en-om_1">Creamos un Redis Model en OM:</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cargar-datos-en-redis_1">Cargar datos en redis</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#si-queremos-conectarnos-con-redis-cloud">Si queremos conectarnos con Redis Cloud</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#queries">Queries</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#redisearch_1">Redisearch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejemplos">EJEMPLOS</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../sql/">SQL</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../GA/">ALGORITMO GENETICO</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../strapi/">STRAPI</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../simpy/">SIMPY</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../git/">GIT</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Dokumentazioa</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>REDIS</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="redis">REDIS</h1>
<p><a href="https://redis-py.readthedocs.io/en/stable/">redis-py</a></p>
<p><a href="Pruebak iteko">https://try.redis.io/</a></p>
<h2 id="basic-data-structures">BASIC DATA STRUCTURES</h2>
<h3 id="keys-and-expiration">Keys and Expiration</h3>
<p><a href="https://redis.io/commands#generic">Documentation</a></p>
<p>Keys are the primary way to access data values. Hay 16 databases, por defecto siempre se utilizará database0. </p>
<p>EJEMPLO (por convención, pero se puede hacer de otra forma):</p>
<pre><code>&quot;user:1000:followers&quot;
</code></pre>
<ul>
<li>user: nombre del objeto</li>
<li>1000: identificador único de la instancia</li>
<li>followers: objeto compuesto</li>
</ul>
<h3 id="set"><code>SET</code></h3>
<p>Para asignar un valor a una llave. </p>
<pre><code>SET customer:1000 &quot;fred&quot;
</code></pre>
<p>En nuestra llave (cliente de ID 1000) <code>customer:1000</code>estará guardado el valor <code>"fred"</code></p>
<p>Si hacemos <code>SET</code> a una llave que no existe la crearemos. si no queremos que esto suceda podemos utilizar <code>NX</code></p>
<pre><code>SET provider:100 &quot;freddy&quot; NX
</code></pre>
<p>Nos retornará <code>OK</code> si no existe y nos devolverá <code>NIL</code> si existe.</p>
<h3 id="get"><code>GET</code></h3>
<p>Para obtener el valor que tiene guardada la llave <code>customer:1000</code></p>
<pre><code>GET customer:1000 =&gt; fred
</code></pre>
<p>En cambio, si queremos que la llave exista antes de hacer <code>SET</code> utilizaremos <code>XX</code> de la misma manera.</p>
<h3 id="keys-and-scan"><code>KEYS</code> and <code>SCAN</code></h3>
<p><code>KEYS</code> itera sobre todas las llaves, para ver si existe la que le hemos pedido. Si la base de datos es grande podría tardar demasiado. 
<code>SCAN</code> itera usando un cursor y devuelve un espacio de referencia. Está bien para usarlo en producción.</p>
<p>EJEMPLOS:</p>
<p>KEYS
Todos los clientes cuyo ID empiezan con 1:</p>
<pre><code>keys customer:1* =&gt; customer:1500
                    customer:1000

</code></pre>
<p>SCAN</p>
<pre><code>SCAN slot [MATCH pattern][COUNT count]
</code></pre>
<pre><code>scan 0 MATCH customer: 1* =&gt; 1) 14336
                             2) empty list or set

scan 14336 MATCH customer:1* =&gt; 1) 14848
                                2) empty list or set

scan 14848 MATCH customer:1* COUNT 10000 =&gt; 1) 1229
                                            2) 1)customer:1500
                                               2)customer:1000
scan 1229 MATCH customer:1* =&gt; 1) 0
                               2) empty list or set

</code></pre>
<p>Cuando aparece 0 significa que no hay nada más sobre lo que iterar.
...</p>
<h3 id="borrar-llaves">Borrar llaves</h3>
<h3 id="del"><code>DEL</code></h3>
<p>Para borrar una llave y el valor asociado a ella o desvincular su llave con el valor.</p>
<pre><code>DEL key[key...]
UNLINK key[key]
</code></pre>
<h3 id="exists"><code>EXISTS</code></h3>
<pre><code>EXISTS server:name =&gt; 1 (existe)
EXISTS server:blabla =&gt; 0 (no existe)
</code></pre>
<p>Es una base de datos que funciona por llave-valor. Un valor siempre se guardará dentro de una llave y la única forma de obtener dicho valor es tener la llave.</p>
<p>Se explicarán los comandos más básicos a continuación, pero la lista completa esta <a href="https://redis.io/commands">aquí</a></p>
<h3 id="incr-y-incrby"><code>INCR</code> y <code>INCRBY</code></h3>
<p>Incrementan el valor de una llave dada. <code>INCR</code> lo incrementa por 1 y <code>INCRBY</code> lo incrementa por el valor que nosotros le proporcionemos.</p>
<p>Son operaciones atómicas. </p>
<pre><code>SET connections 10
INCR connections
GET connections =&gt; 11
</code></pre>
<pre><code>SET connections 10
INCRBY connections 100
GET connections =&gt; 110
</code></pre>
<h3 id="decr-y-decrby"><code>DECR</code> y <code>DECRBY</code></h3>
<p>Decrementan el valor de una llave dada. <code>INCR</code> lo incrementa por 1 y <code>INCRBY</code> lo incrementa por el valor que nosotros le proporcionemos.</p>
<h3 id="expire-y-ttl"><code>EXPIRE</code> y <code>TTL</code></h3>
<p>Para decir que una llave tiene que existir solo para un tiempo especificado en segundos.</p>
<pre><code>SET resource:lock &quot;Redis Demo&quot;
EXPIRE resource:lock 120
</code></pre>
<p>Con <code>TTL</code> podremos mirar cuento le queda a una llave:</p>
<pre><code>TTL resource:lock =&gt; 113
</code></pre>
<p>Si TTL es -1 significa que esa llave es para siempre. </p>
<h3 id="listas">LISTAS</h3>
<h2 id="python">PYTHON</h2>
<p>redis-py library</p>
<pre><code>pip install redis
</code></pre>
<h3 id="connect-to-redis">Connect to redis:</h3>
<pre><code>import os

import pytest
import redis

USERNAME = os.environ.get('REDISOLAR_REDIS_USERNAME')
PASSWORD = os.environ.get('REDISOLAR_REDIS_PASSWORD')


@pytest.fixture
def redis_connection(app):
    client_kwargs = {
        &quot;host&quot;: app.config['REDIS_HOST'],
        &quot;port&quot;: app.config['REDIS_PORT'],
        &quot;decode_responses&quot;: True
    }

    if USERNAME:
        client_kwargs[&quot;username&quot;] = USERNAME
    if PASSWORD:
        client_kwargs[&quot;password&quot;] = PASSWORD

    yield redis.Redis(**client_kwargs)


def test_say_hello(redis_connection):
    result = redis_connection.set(&quot;hello&quot;, &quot;world&quot;)
    value = redis_connection.get(&quot;hello&quot;)
    assert result is True
    assert value == &quot;world&quot;
</code></pre>
<h3 id="redis-clients">Redis Clients</h3>
<p>Gestiona conexiones, implementa el protocolo redis (RESP) y nos deja usar un lenguaje sencillo (GET, SET, INCR...).</p>
<p><a href="https://walrus.readthedocs.io/en/latest/">Walrus</a></p>
<p><a href="https://redis-py.readthedocs.io/en/stable/">redis-py</a></p>
<p>Utilizaremos <code>redis-py</code> como nuestra librería cliente.</p>
<h4 id="como-conectarse-a-redis-utilizando-redis-py">Cómo conectarse a redis utilizando <code>redis-py</code></h4>
<pre><code>import redis
from redis.sentinel import Sentinel
from rediscluster import RedisCluster


def connection_examples():
    # Connect to a standard Redis deployment.
    client = redis.Redis(&quot;localhost&quot;, port=6379, decode_responses=True,
                         max_connections=20)

    # Read and write through the client.
    client.set(&quot;foo&quot;, &quot;bar&quot;)
    client.get(&quot;foo&quot;)
</code></pre>
<h4 id="basic-operations">Basic operations</h4>
<p>Redys type &gt; Python type:</p>
<ul>
<li>String &gt; bytes or string</li>
<li>List &gt; list of bytes or strings</li>
<li>Set &gt; set of bytes or strings</li>
<li>Hash &gt; dictionary</li>
</ul>
<pre><code>PLANETS = [
    &quot;Mercury&quot;, &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,
    &quot;Uranus&quot;, &quot;Neptune&quot;, &quot;Pluto&quot;
]

EARTH_KEY = &quot;earth&quot;

## LISTS

def test_redis_list(redis, key_schema):
    key = key_schema.planets_list_key()

    assert len(PLANETS) == 11

    # Add all test planets to a Redis list
    result = redis.rpush(key, *PLANETS)

    # Check that the length of the list in Redis is the same
    assert result == len(PLANETS)

    # Get the planets from the list
    # Note: LRANGE is an O(n) command. Be careful running this command
    # with large lists.
    planets = redis.lrange(key, 0, -1)
    assert planets == PLANETS

    # Remove the elements that we know are duplicates
    # Note: O(n) operation.
    redis.lrem(key, 1, &quot;Mercury&quot;)
    redis.lrem(key, 1, &quot;Earth&quot;)

    planet = redis.rpop(key)
    assert planet == &quot;Pluto&quot;

    assert redis.llen(key) == 8

## SETS

def test_redis_set(redis, key_schema):
    key = key_schema.planets_set_key()

    # Add planets to a Redis set
    redis.sadd(key, *PLANETS)

    # Return the cardinality of the set
    assert redis.scard(key) == 9

    # Fetch all values from the set
    # Note: SMEMBERS is an O(n) command. Be careful running this command
    # with high-cardinality sets. Consider SSCAN as an alternative.
    assert redis.smembers(key) == set(PLANETS)

    # Pluto is, of course, no longer a first-class planet. Remove it.
    response = redis.srem(key, &quot;Pluto&quot;)
    assert response == 1

    # Now we have 8 planets, as expected.
    assert redis.scard(key) == 8

## HASHES

def test_redis_hash(redis):
    earth_properties = {
        &quot;diameter_km&quot;: &quot;12756&quot;,
        &quot;day_length_hrs&quot;: &quot;24&quot;,
        &quot;mean_temp_c&quot;: &quot;15&quot;,
        &quot;moon_count&quot;: &quot;1&quot;
    }

    # Set the fields of the hash.
    redis.hset(EARTH_KEY, mapping=earth_properties)

    # Get the hash we just created back from Redis.
    stored_properties = redis.hgetall(EARTH_KEY)
    assert stored_properties == earth_properties

    # Test that we can get a single property.
    assert redis.hget(EARTH_KEY, &quot;diameter_km&quot;) == earth_properties[&quot;diameter_km&quot;]
</code></pre>
<p>CUIDADO!! Algunos métodos pueden ser lentos. Para muchos datos, hay que utilizar los métodos de la familia SCAN.</p>
<h3 id="daos">DAOs</h3>
<p>Get started with redis cloud:</p>
<p>Create a subscription and a database. To connect with the database we need:</p>
<ul>
<li><code>public endpoint</code> for the host and port</li>
<li><code>password</code> for the authorization</li>
</ul>
<p>First code:</p>
<pre><code>import redis

redis = redis.Redis(
     host='redis-16018.c228.us-central1-1.gce.cloud.redislabs.com',
     port='16018',
     password='AAa6DTbT7c0kYoZuVDM3mLTrEuGMinDt')

redis.set('mykey', 'Hello from Python!')
value = redis.get('mykey')
print(value)

redis.zadd('vehicles', {'car': 0})
redis.zadd('vehicles', {'bike': 0})
vehicles = redis.zrange('vehicles', 0, -1)
print(vehicles)
</code></pre>
<p>Output:</p>
<pre><code>b'Hello from Python!'
[b'bike', b'car']
</code></pre>
<h2 id="redisearch">REDISEARCH</h2>
<p><a href="https://developer.redis.com/howtos/redisearch/?s=redise">Tutorial</a></p>
<p><a href="https://github.com/RediSearch/redisearch-py#aggregations">Aggregations tutorial</a></p>
<p><a href="https://github.com/RediSearch/redisearch-py">RediSearch en python</a></p>
<p>Redisearch es una herramienta de búsqueda. </p>
<pre><code>pip install redisearch
</code></pre>
<p>Crear una instancia cliente. <a href="https://faun.pub/redisearch-using-python-client-3581309e3475">tutorial</a></p>
<pre><code>from redisearch import Client

client = Client(&quot;my-index&quot;)
</code></pre>
<p><a href="https://d128ysc22mu7qe.cloudfront.net/python_client/">Client Python API</a></p>
<pre><code>from redis import ResponseError
from redisearch import Client, IndexDefinition, TextField

SCHEMA = (
    TextField(&quot;title&quot;, weight=5.0),
    TextField(&quot;body&quot;)
)

client = Client(&quot;my-index&quot;)

definition = IndexDefinition(prefix=['blog:'])

try:
    client.info()
except ResponseError:
    # Index does not exist. We need to create it!
    client.create_index(SCHEMA, definition=definition)
</code></pre>
<pre><code>from redisearch import Client, TextField, NumericField, Query

# Creating a client with a given index name
client = Client('myIndex')

# Creating the index definition and schema
client.create_index([TextField('title', weight=5.0), TextField('body')])

# Indexing a document
client.add_document('doc1', title = 'RediSearch', body = 'Redisearch implements a search engine on top of redis')

# Simple search
res = client.search(&quot;search engine&quot;)

# the result has the total number of results, and a list of documents
print res.total # &quot;1&quot;
print res.docs[0].title

# Searching with snippets
res = client.search(&quot;search engine&quot;, snippet_sizes = {'body': 50})

# Searching with complex parameters:
q = Query(&quot;search engine&quot;).verbatim().no_content().paging(0,5)
res = client.search(q)
</code></pre>
<h3 id="querying">QUERYING</h3>
<h4 id="finding-exact-string-matches">Finding exact string matches</h4>
<h2 id="redis-om">REDIS OM</h2>
<p><a href="https://github.com/redis/redis-om-python">GitHub</a></p>
<p><a href="https://www.youtube.com/watch?v=DFNKmbGKa5w">Yotube tutorial</a></p>
<p><a href="https://www.youtube.com/watch?v=UhnEyMDWuyI">Youtube tutorial</a></p>
<p><a href="https://university.redis.com/courses/ru203/">Curso de redis</a></p>
<p>EJEMPLO:
Vamos a montar un refugio de animales y tenemos un csv con los siguientes campos: <code>name, species, age, weight, sex, fee, children, other_animals, description</code>.</p>
<h4 id="creamos-un-redis-model-en-om">Creamos un Redis Model en OM:</h4>
<pre><code>from typing import Text
from redis_om import (Field, HashModel)

class Adoptable (HashModel):
    name: str = Field(index=True)
    species: str = Field(index=True)
    age: str = Field(index=True)
    weight: float = Field(index=True)
    sex: str = Field(index=True)
    fee: str = Field(index=True)
    children: str = Field(index=True)
    other_animals: str = Field(index=True)
    description: str = Field(index=True, full_text_search=True) #Le estamos diciendo a redis cómo queremos que lo indexe, ya que queremos ser capaces de hacer un 'full text search' (utilizará un query de redisearch)
</code></pre>
<p>Lo que estamos modelando se guardará como un hash en redis. Le decimos los campos (Field) que queremos que guarde y que queremos que los indexe. </p>
<p>Lo indexará con redisearch y creará un índice para mantenimiento y búsqueda. De esta forma, cuando creemos instancias, <code>client</code> gestionará esto volviendolo a guardar en redis.</p>
<p>Cada animal se guardará asociado a un valor (tal y como funciona redis, con clave-valor), pero nosostros queremos ser capaces de hacer búsquedas dependiendo de algún campo (ej. queremos un perro que pese menos de 20kg). Reisearch nos ayudará en esto.</p>
<p>Si quisieramos modelar algo con campos anidados (que no sea clave-valor como en este caso) podríamos utilizar el modelado JSON de redis. Ambos son modelos <code>pedantic</code> (una librería de validación de python) por lo que podemos añadir criterios adicionales (que un campo sea un email, que un int esté entre valores que especifiquemos...). </p>
<h4 id="cargar-datos-en-redis">Cargar datos en redis</h4>
<p>Creamos una base de datos en redis a partir de un CSV:</p>
<pre><code>import csv
from adoptable import Adoptable
from redis_om impor Migrator

with open['animal_data.csv'] as csv_file:
    animail_reader = csv.DictReader(csv_file)

    for animal in animal_reader:
        adoptable = Adoptable(**animal)
        print(f&quot;{animal[name]} has pk = {adoptable.pk}&quot;) # pk lo crea redis OM como clave primaria
        adoptable.save()

# Hacer la migración de datos
Migrator().run()
</code></pre>
<p>Con <code>pk</code> estamos creando claves que identifiquen a cada animal como único localmente antes de guardarlo en redis. </p>
<p>Con <code>Migrator.run()</code> activamos algo parecido a "un detector de cambios". Así todo lo que hagamos estará registrado siempre. </p>
<p>Podemos descargarnos <a href="https://redis.com/es/redis-enterprise/redisinsight/#insight-form">RedisInsight</a> para interactuar con nuestra base de datos. Es una interfaz donde podemos ver y gestionar nuestros datos fácilmente. </p>
<h4 id="querys">Querys</h4>
<pre><code>from adoptable import Adoptable

def show_result(results):
    for adoptable in results:
        print(adoptable)
        print(&quot;&quot;)

def find_by_name():
    print(&quot;find by name: &quot;)
    return Adoptable.find(Adoptable.name == &quot;Luna&quot;).all()

def find_male_dogs():
    print(&quot;find male dogs: &quot;)
    return Adoptable.find((Adoptable.species == &quot;dog&quot;) &amp;
                         (Adoptable.sex == &quot;m&quot;)
                         )

def find_dogs_in_age_range():
    print(&quot;find dogs in ages range: &quot;)
    return Adoptable.find((Adoptable.species == &quot;dog&quot;) &amp;
                         (Adoptable.age &lt; 8) &amp;
                         (Adoptable.age &lt; 11)
                         ).sort_by(&quot;age&quot;)


def find_cats_good_with_children():
    print(&quot;find cats good with children: &quot;)
    return Adoptable.find((Adoptable.species == &quot;cat&quot;) &amp;
                            (Adoptable.children == &quot;y&quot;) &amp;
                            (Adoptable.description % &quot;play&quot;) &amp;
                            ~(Adoptable.description % &quot;anxious&quot;) &amp;
                            ~(Adoptable.description % &quot;nervous&quot;)
                            )

show_results(find_by_name())
</code></pre>
<p>En la última función nos basamos en redisearch para las búsquedas. Si queremos buscar más allá de valores concretos, nos podemos fijar en la descripción. Al buscar con <code>%</code> lo que hacemos es buscar una palabra parecida a la que estamos buscando, incluyendo también esa palabra. En cambio, con el símbolo <code>~</code> lo que hacemos es excluir esa palabra y parecidas de nuestra búsqueda. </p>
<h2 id="redis_om-y-redisearch">REDIS_OM y REDISEARCH</h2>
<p><a href="https://developer.redis.com/howtos/redisearch/?s=redise">Tutorial redisearch</a></p>
<p><a href="https://github.com/RediSearch/redisearch-py#aggregations">Aggregations tutorial redisearch</a></p>
<p><a href="https://github.com/RediSearch/redisearch-py">RediSearch en python</a></p>
<p><a href="https://github.com/redis/redis-om-python">GitHub Redis_OM</a></p>
<p><a href="https://www.youtube.com/watch?v=DFNKmbGKa5w">Yotube tutorial</a></p>
<p><a href="https://www.youtube.com/watch?v=UhnEyMDWuyI">Youtube tutorial</a></p>
<p><a href="https://university.redis.com/courses/ru203/">Curso de redis oficial</a></p>
<p>Vamos a manejar una base de datos con los siguientes campos: <code>firstName,lastName,salary,department,isAdmin</code></p>
<h3 id="iniciar-redis-en-windows">Iniciar Redis en Windows</h3>
<p>Tres opciones:</p>
<p>1) WSL DE LINUX</p>
<p>2) CON DOCKER</p>
<ul>
<li>Instalar docker y preparamos un puerto localhost libre.</li>
<li>Preparar un documento 'docker-compose.yaml'</li>
</ul>
<pre><code>    version: &quot;3.9&quot;
    services:
    redis:
        container_name: redis_om_python_demo
        image: &quot;redislabs/redisearch:edge&quot;
        ports:
        - 6379:6379
        deploy:
        replicas: 1
        restart_policy:
            condition: on-failure
</code></pre>
<ul>
<li>Instalamos los paquetes necesarios (algunos de ellos están en <code>requirements.txt</code>)</li>
</ul>
<pre><code>    pip install -r requirements.txt
</code></pre>
<ul>
<li>En otra terminal ejecutamos <code>docker-compose up</code> y habremos añadido el container que queríamos en docker.</li>
</ul>
<p>3) REDIS CLOUD</p>
<ul>
<li><code>set REDIS_OM_URL = redis://username:password@public-endpoint/dataset_name</code></li>
<li><a href="https://www.mortensi.com/2021/12/connect-to-redis-with-python/">Blog explicado</a></li>
</ul>
<h4 id="redisinsight">RedisInsight</h4>
<p><a href="https://redis.com/es/redis-enterprise/redisinsight/#insight-form">Link: RedisInsight</a></p>
<p>Es una interfaz para ver qué está pasando. Traer la base de datos especificando <code>host</code> y <code>port</code>. Si estamos en cloud también tendremos que meter la contraseña. </p>
<h3 id="creamos-un-redis-model-en-om_1">Creamos un Redis Model en OM:</h3>
<pre><code>from typing import Text
from redis_om import (Field, HashModel)
from redisearch.client import TagField

class Employee(HashModel):
    firstName: str = Field(index=True)
    lastName: str = Field(index=True)
    salary: int = Field(index=True)
    department: str = Field(index=True)
    isAdmin: int = Field(index=True)
</code></pre>
<p>Lo que estamos modelando se guardará como un hash en redis. Le decimos los campos (Field) que queremos que guarde y que queremos que los indexe. </p>
<p>Lo indexará con redisearch y creará un índice para mantenimiento y búsqueda. </p>
<p>Cada persona se guardará asociado a un valor (tal y como funciona redis, con clave-valor), pero nosostros queremos ser capaces de hacer búsquedas dependiendo de algún campo. Reisearch nos ayudará en esto.</p>
<p>Si quisieramos modelar algo con campos anidados (que no sea clave-valor como en este caso) podríamos utilizar el modelado JSON de redis. Ambos son modelos <code>pedantic</code> (una librería de validación de python) por lo que podemos añadir criterios adicionales (que un campo sea un email, que un int esté entre valores que especifiquemos...). </p>
<h3 id="cargar-datos-en-redis_1">Cargar datos en redis</h3>
<p>Creamos una base de datos en redis a partir de un CSV. Es algo que ejecutaremos solamente una vez.</p>
<pre><code>import csv

from employee import Employee
from redis_om import Migrator

with open('employee.csv') as csv_file:
    employees = csv.DictReader(csv_file)

    for employee in employees:
        emp = Employee(**employee)

        # print(f&quot;{employee['firstName']} -&gt; {emp.pk}&quot;) 
        emp.save()

# Create a RediSearch index
Migrator().run()
</code></pre>
<p>Con <code>pk</code> estamos creando claves que identifiquen a cada persona como único localmente, antes de guardarlo en redis. </p>
<p>Con <code>Migrator().run()</code> activamos algo parecido a "un detector de cambios". Así todo lo que hagamos estará registrado siempre. </p>
<p>Lo ejecutamos en la terminal:</p>
<pre><code>py upload_employee.py
</code></pre>
<p>Podemos verificar que de verdad se ha subido en RedisInsight</p>
<h4 id="si-queremos-conectarnos-con-redis-cloud">Si queremos conectarnos con Redis Cloud</h4>
<p>Ejecutamos en el cmd:</p>
<pre><code>set REDIS_OM_URL = redis://username:password@public-endpoint/dataset_name
</code></pre>
<p>Y realizamos los pasos de arriba para cargar los datos.</p>
<p>Me ha dado error y lo hemos forzado en el código. Definimos la conexión a nuestra base de datos antes de importar lo demás.</p>
<pre><code>import csv

import os

os.environ[&quot;REDIS_OM_URL&quot;]=&quot;redis://default:CgdemOw59KKOuX4ZugQVaThJv738hBAf@redis-10742.c124.us-central1-1.gce.cloud.redislabs.com:10742/books&quot;

from employee import Employee
from redis_om import Migrator

with open('employe.csv') as csv_file:
    employees = csv.DictReader(csv_file)

    for employee in employees:
        emp = Employee(**employee)

        print(f&quot;{employee['firstName']} -&gt; {emp.pk}&quot;)
        emp.save()

# Create a RediSearch index
Migrator().run()

</code></pre>
<h3 id="queries">Queries</h3>
<p>Podemos hacerlo con redisOM o redisearch.</p>
<h4 id="redisearch_1">Redisearch</h4>
<p>Para Redisearch necesitamos definir un <code>client</code>.</p>
<pre><code>from redisearch import Client, IndexDefinition, TextField, NumericFieldTagField, GeoField

def initializeClient():
    SCHEMA = (
        TextField(&quot;firstName&quot;),
        TextField(&quot;lastName&quot;),
        NumericField(&quot;salary&quot;),
        TextField(&quot;department&quot;),
        NumericField(&quot;isAdmin&quot;),
        TagField(&quot;tag&quot;),
        GeoField(&quot;location&quot;)
    )
    client = Client(&quot;myIndex&quot;)
    definition = IndexDefinition(prefix=[':employee.Employee:']) # lo que tienen en común antes del hash
    try: # No podemos cargar un cliente con el mismo index
        client.info()
    except ResponseError:
        # Index does not exist. We need to create it!
        client.create_index(SCHEMA, definition=definition)
    return client

client = initializeClient()
</code></pre>
<h4 id="ejemplos">EJEMPLOS</h4>
<h5 id="imports">Imports</h5>
<pre><code>from employee import Employee
from redis import ResponseError
from redisearch import Client, IndexDefinition, TextField, NumericField, TagField, GeoField
from redisearch import reducers
from redisearch.aggregation import AggregateRequest, Asc, Desc
</code></pre>
<h5 id="task-1-find-by-first-name">Task 1 : find by first name</h5>
<p>OM: </p>
<pre><code>def find_by_first_name():
    return Employee.find(Employee.firstName == 'ahmad').all() # search based on first name (could be done like this)
</code></pre>
<p>Redisearch: </p>
<pre><code>def find_by_first_name_redisearch(client):
    res =  client.search(&quot;@firstName:ahmad&quot;)
    return res
</code></pre>
<h5 id="task-2-find-by-first-name-autocompletando-con-redisearch">Task 2 : find by first name (autocompletando con redisearch)</h5>
<pre><code>def find_by_name_wildcard_redisearch(client):
    res =  client.search(&quot;@firstName:br*&quot;)
    for result in res.docs:
        print(result)
</code></pre>
<h5 id="task-3-find-by-first-and-last-name-con-om">Task 3: Find by first and last name con OM</h5>
<pre><code>def find_by_first_and_last_name():
    return Employee.find((Employee.firstName == 'ahmad') &amp; (Employee.lastName == 'bazzi')).all()
</code></pre>
<h5 id="task-4-sort-in-ascending">Task 4: Sort in ascending</h5>
<p>OM: </p>
<pre><code>def sort_by_salary():
    return Employee.find(Employee.salary&gt;0).sort_by(&quot;salary&quot;)
</code></pre>
<h5 id="task-5-sort-in-descending-with-redisearch">Task 5: Sort in descending with redisearch:</h5>
<pre><code>def sort_by_salary_redisearch_descending():
    request = AggregateRequest('*').group_by(['@salary','@firstName'], reducers.count().alias('count')).sort_by(Desc('@salary'))
    result = client.aggregate(request)
    for r in result.rows:   
        print(r)
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../sql/" class="btn btn-neutral float-right" title="SQL">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../prophet/" class="btn btn-neutral" title="PROPHET"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../prophet/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../sql/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
